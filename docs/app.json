[{"name": "app.py", "content": "#!/usr/bin/env python\n# coding: utf-8\n\nfrom __future__ import annotations\n\nimport pandas as pd\nimport re\nimport requests\nimport sys\n\nfrom datetime import datetime\nfrom collections import Counter\nfrom io import StringIO\nfrom urllib.request import urlretrieve, Request, urlopen\nfrom urllib.parse import quote\nfrom shiny import App, reactive, render, ui\n\ndef generate_url(startdate, enddate, passkey):\n    urlstem = 'https://www.amion.com/cgi-bin/ocs?Lo={}&Rpt=625ctabs'.format(\n        passkey\n    )\n\n    y, m, d = startdate.strftime('%y'), startdate.month, startdate.day\n    delta = (enddate - startdate).days\n    datestring = '&Day={}&Month={}-{}&Days={}'.format(d, m, y, delta)\n\n    return urlstem + datestring\n\ndef fetch_table(url):\n    headers = {\n        'User-Agent': (\n            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) '\n            'AppleWebKit/537.36 (KHTML, like Gecko) '\n            'Chrome/120.0.0.0 Safari/537.36'\n        ),\n        'Accept': 'text/plain, */*;q=0.9',\n        'Connection': 'keep-alive',\n    }\n\n    req = Request(url, headers = headers)\n    with urlopen(req, timeout = 60) as resp:\n        text = resp.read().decode('utf-8', errors = 'replace')\n\n    return StringIO(text)\n\ndef download_df(academicYear, passkey):\n    if academicYear == 'AY22':\n        startdate = datetime(2022, 6, 24)\n        enddate = datetime(2023, 6, 27)\n    elif academicYear == 'AY23':\n        startdate = datetime(2023, 6, 28)\n        enddate = datetime(2024, 6, 30)\n    elif academicYear == 'AY24':\n        startdate = datetime(2024, 7, 1)\n        enddate = datetime(2025, 6, 29)\n    elif academicYear == 'AY25':\n        startdate = datetime(2025, 6, 30)\n        enddate = datetime(2026, 6, 29)\n    else:\n        startdate = datetime(1, 1, 1)\n        enddate = datetime(1, 1, 2)\n\n    passkey_encoded = quote(passkey)\n    url = generate_url(startdate, enddate, passkey_encoded)\n    file_like = fetch_table(url)\n\n    try:\n        df = pd.read_table(\n            file_like,\n            skiprows = 7,\n            header = None,\n            usecols = [0, 3, 6, 7, 8, 9, 15, 16],\n        )\n    except pd.errors.EmptyDataError:\n        return pd.DataFrame([])\n\n    df.columns = [\n        'Name',\n        'Assignment',\n        'Date',\n        'Start',\n        'Stop',\n        'Role',\n        'Type',\n        'Assgn',\n    ]\n\n    df = df[~df.Role.isnull()]\n    df = df[df.Role != 'Services']\n    df = df[df.Role.str[-1] != '*']\n\n    df['Name'] = (\n        df['Name']\n        .astype(str)\n        .str.replace(\"'\", '', regex = False)\n        .str.replace('\"', '', regex = False)\n        .str.strip()\n    )\n\n    df['Assignment'] = (\n        df['Assignment']\n        .astype(str)\n        .str.strip()\n        .str.replace(r'\\s+', ' ', regex = True)\n    )\n\n    return df\n\ndef download_df_multi_year(academicYears, passkey):\n    dfs = []\n    for ay in academicYears:\n        dfi = download_df(ay, passkey)\n        if not dfi.empty:\n            dfi['AcademicYear'] = ay\n            dfs.append(dfi)\n\n    if not dfs:\n        return pd.DataFrame([])\n\n    return pd.concat(dfs, ignore_index = True)\n\ndef _parse_date_column(df: pd.DataFrame) -> pd.DataFrame:\n    df = df.copy()\n    df['Date_dt'] = pd.to_datetime(\n        df['Date'],\n        errors = 'coerce',\n        infer_datetime_format = True\n    )\n    return df\n\ndef _clean_rotation_text(s: str) -> str:\n    s = str(s).strip()\n    s = re.sub(r'\\s+', ' ', s)\n    s = re.sub(r',\\s*(am|pm)\\s*$', '', s, flags = re.IGNORECASE)\n    return s\n\ndef _make_exclude_regex():\n    banned_terms = [\n        'Conf', 'Didactic', 'Exam', 'Panel', 'Retreat', 'R1', 'R2', 'R3',\n        'SOM Resc', 'Resc', 'ABIM', 'Board Prep',\n        'Chief', 'Clinic', 'Holiday', 'Off', 'Immersion', 'Academic',\n        'Vacation', 'Sick', 'Interview', 'PPC', 'Shadow', 'TBD', 'Jury',\n        'ACGME'\n    ]\n    pattern = r'(' + r'|'.join(re.escape(t) for t in banned_terms) + r')'\n    return re.compile(pattern, flags = re.IGNORECASE)\n\n_EXCLUDE_RE = _make_exclude_regex()\n\ndef _prepare_rotations_df(df: pd.DataFrame) -> pd.DataFrame:\n    df2 = df.copy()\n    df2 = _parse_date_column(df2)\n\n    df2['Rotation'] = df2['Assignment'].map(_clean_rotation_text)\n\n    df2 = df2[df2['Rotation'].notna()]\n    df2 = df2[df2['Rotation'].astype(str).str.strip() != '']\n    df2 = df2[~df2['Rotation'].str.contains(_EXCLUDE_RE, na = False)]\n\n    df2 = df2[df2['Name'].notna()]\n    df2 = df2[df2['Name'].astype(str).str.strip() != '']\n\n    df2 = df2[df2['Date_dt'].notna()]\n\n    return df2[['Name', 'Rotation', 'Date_dt']].copy()\n\ndef _rotations_with_repeat_use(df_rot: pd.DataFrame, min_count = 6, window_days = 92) -> set:\n    window_ns = int(window_days * 24 * 60 * 60 * 1_000_000_000)\n    qualifying = set()\n\n    df_rot = df_rot.copy()\n    df_rot['t'] = df_rot['Date_dt'].values.astype('datetime64[ns]').astype('int64')\n    df_rot = df_rot.sort_values(['Name', 'Rotation', 't'])\n\n    for (name, rot), g in df_rot.groupby(['Name', 'Rotation'], sort = False):\n        t = g['t'].to_numpy()\n        i = 0\n        for j in range(len(t)):\n            while t[j] - t[i] > window_ns:\n                i += 1\n            if (j - i + 1) >= min_count:\n                qualifying.add(rot)\n                break\n\n    return qualifying\n\ndef build_master_rotations(df: pd.DataFrame) -> list[str]:\n    df_rot = _prepare_rotations_df(df)\n    qualifying = _rotations_with_repeat_use(df_rot = df_rot, min_count = 6, window_days = 92)\n    return sorted(qualifying, key = lambda x: x.lower())\n\ndef rotations_unfilled_in_month(df: pd.DataFrame, master_rotations: list[str], month_yyyy_mm: str) -> list[str]:\n    df_rot = _prepare_rotations_df(df)\n\n    month_start = pd.to_datetime(month_yyyy_mm + '-01')\n    month_end = month_start + pd.offsets.MonthBegin(1)\n\n    in_month = df_rot[(df_rot['Date_dt'] >= month_start) & (df_rot['Date_dt'] < month_end)]\n    filled = set(in_month['Rotation'].dropna().unique().tolist())\n\n    unfilled = [r for r in master_rotations if r not in filled]\n    unfilled = sorted(set(unfilled), key = lambda x: x.lower())\n    unfilled = [r.replace('*', '') for r in unfilled]\n    return unfilled\n\napp_ui = ui.page_fluid(\n    ui.h3('Amion Rotation Openings Checker'),\n    ui.layout_sidebar(\n        ui.sidebar(\n            ui.input_password('passkey', 'Amion passkey (hidden)'),\n            ui.input_select(\n                'years',\n                'Academic years to scan (master list)',\n                choices = ['AY23', 'AY24', 'AY25'],\n                selected = ['AY23', 'AY24', 'AY25'],\n                multiple = True,\n            ),\n            ui.input_text('month', 'Month to check (YYYY-MM)', value = '2026-02'),\n            ui.input_action_button('load', 'Load / Refresh data'),\n            ui.input_action_button('check', 'Check month'),\n            width = 4\n        ),\n        ui.div(\n            ui.output_text_verbatim('status'),\n            ui.hr(),\n            ui.h4('Master rotations (count)'),\n            ui.output_text('master_count'),\n            ui.h4('Rotations that may have openings'),\n            ui.output_table('unfilled_table'),\n            ui.h4('Raw list'),\n            ui.output_text_verbatim('unfilled_list'),\n        )\n    )\n)\n\ndef server(input, output, session):\n    df_state = reactive.Value(pd.DataFrame([]))\n    master_state = reactive.Value([])\n    unfilled_state = reactive.Value([])\n    status_state = reactive.Value('Ready. Enter passkey and click Load / Refresh data.')\n\n    @reactive.Effect\n    @reactive.event(input.load)\n    def _load_data():\n        passkey = (input.passkey() or '').strip()\n        years = list(input.years() or [])\n\n        if passkey == '':\n            status_state.set('No passkey entered.')\n            df_state.set(pd.DataFrame([]))\n            master_state.set([])\n            unfilled_state.set([])\n            return\n\n        if not years:\n            status_state.set('No academic years selected.')\n            df_state.set(pd.DataFrame([]))\n            master_state.set([])\n            unfilled_state.set([])\n            return\n\n        try:\n            status_state.set('Loading data from Amion...')\n            df = download_df_multi_year(years, passkey)\n\n            if df.empty:\n                status_state.set('Pulled 0 rows (or export empty).')\n                df_state.set(pd.DataFrame([]))\n                master_state.set([])\n                unfilled_state.set([])\n                return\n\n            status_state.set('Building master rotation list...')\n            master = build_master_rotations(df)\n\n            df_state.set(df)\n            master_state.set(master)\n            unfilled_state.set([])\n\n            status_state.set(\n                'Loaded rows = {}, master rotations = {}.'.format(len(df), len(master))\n            )\n\n        except Exception as e:\n            status_state.set('Load failed (did not crash UI): {}'.format(e))\n            df_state.set(pd.DataFrame([]))\n            master_state.set([])\n            unfilled_state.set([])\n\n    @reactive.Effect\n    @reactive.event(input.check)\n    def _check_month():\n        month = (input.month() or '').strip()\n        df = df_state.get()\n        master = master_state.get()\n\n        if df.empty or not master:\n            status_state.set('No data/master list loaded. Click Load / Refresh data first.')\n            unfilled_state.set([])\n            return\n\n        if not re.match(r'^\\d{4}-\\d{2}$', month):\n            status_state.set('Invalid month format. Use YYYY-MM (example: 2026-02).')\n            unfilled_state.set([])\n            return\n\n        try:\n            unfilled = rotations_unfilled_in_month(df, master, month)\n            unfilled_state.set(unfilled)\n            status_state.set('Computed openings for {} (n = {}).'.format(month, len(unfilled)))\n        except Exception as e:\n            status_state.set('Check failed: {}'.format(e))\n            unfilled_state.set([])\n\n    @output\n    @render.text\n    def status():\n        return status_state.get()\n\n    @output\n    @render.text\n    def master_count():\n        return str(len(master_state.get()))\n\n    @output\n    @render.table\n    def unfilled_table():\n        return pd.DataFrame({'Rotation': unfilled_state.get()})\n\n    @output\n    @render.text\n    def unfilled_list():\n        unfilled = unfilled_state.get()\n        if not unfilled:\n            return ''\n        return '\\n'.join(['- {}'.format(r) for r in unfilled])\n\napp = App(app_ui, server)", "type": "text"}]